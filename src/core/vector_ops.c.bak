#include "../../include/kisa.h"
#include <string.h>
#include <math.h>

// 位反转置换辅助函数
static uint32_t reverse_bits_helper(uint32_t x, int bits) {
    uint32_t result = 0;
    for (int i = 0; i < bits; i++) {
        result = (result << 1) | (x & 1);
        x >>= 1;
    }
    return result;
}

// 向量位反转置换函数声明
static void bit_reverse(vector_reg_t* result, vector_reg_t* input);

#ifdef __aarch64__

// Helper function to get lane value (float)
static float get_lane_value(const float32x4_t* low, const float32x4_t* high, int idx) {
    if (idx < 4) {
        switch(idx) {
            case 0: return vgetq_lane_f32(*low, 0);
            case 1: return vgetq_lane_f32(*low, 1);
            case 2: return vgetq_lane_f32(*low, 2);
            case 3: return vgetq_lane_f32(*low, 3);
            default: return 0.0f;
        }
    } else {
        switch(idx - 4) {
            case 0: return vgetq_lane_f32(*high, 0);
            case 1: return vgetq_lane_f32(*high, 1);
            case 2: return vgetq_lane_f32(*high, 2);
            case 3: return vgetq_lane_f32(*high, 3);
            default: return 0.0f;
        }
    }
}

// Helper function to set lane value (float)
static void set_lane_value(float32x4_t* low, float32x4_t* high, int idx, float value) {
    if (idx < 4) {
        switch(idx) {
            case 0: *low = vsetq_lane_f32(value, *low, 0); break;
            case 1: *low = vsetq_lane_f32(value, *low, 1); break;
            case 2: *low = vsetq_lane_f32(value, *low, 2); break;
            case 3: *low = vsetq_lane_f32(value, *low, 3); break;
        }
    } else {
        switch(idx - 4) {
            case 0: *high = vsetq_lane_f32(value, *high, 0); break;
            case 1: *high = vsetq_lane_f32(value, *high, 1); break;
            case 2: *high = vsetq_lane_f32(value, *high, 2); break;
            case 3: *high = vsetq_lane_f32(value, *high, 3); break;
        }
    }
}

// Helper function to get lane value (int32)
static int32_t get_lane_value_s32(const int32x4_t* vec, int idx) {
    switch(idx) {
        case 0: return vgetq_lane_s32(*vec, 0);
        case 1: return vgetq_lane_s32(*vec, 1);
        case 2: return vgetq_lane_s32(*vec, 2);
        case 3: return vgetq_lane_s32(*vec, 3);
        default: return 0;
    }
}

// Helper function to set lane value (int32)
static void set_lane_value_s32(int32x4_t* vec, int idx, int32_t value) {
    switch(idx) {
        case 0: *vec = vsetq_lane_s32(value, *vec, 0); break;
        case 1: *vec = vsetq_lane_s32(value, *vec, 1); break;
        case 2: *vec = vsetq_lane_s32(value, *vec, 2); break;
        case 3: *vec = vsetq_lane_s32(value, *vec, 3); break;
    }
}

// Complex number structure for ARM NEON
typedef struct {
    float32x4_t real_low;
    float32x4_t real_high;
    float32x4_t imag_low;
    float32x4_t imag_high;
} complex_neon_t;

// Helper functions for NEON lane access
static inline int32_t get_lane_value_low(int32x4_t vec, int index) {
    switch(index) {
        case 0: return vgetq_lane_s32(vec, 0);
        case 1: return vgetq_lane_s32(vec, 1);
        case 2: return vgetq_lane_s32(vec, 2);
        case 3: return vgetq_lane_s32(vec, 3);
        default: return 0;
    }
}

static inline int32x4_t set_lane_value_low(int32x4_t vec, int32_t value, int index) {
    switch(index) {
        case 0: return vsetq_lane_s32(value, vec, 0);
        case 1: return vsetq_lane_s32(value, vec, 1);
        case 2: return vsetq_lane_s32(value, vec, 2);
        case 3: return vsetq_lane_s32(value, vec, 3);
        default: return vec;
    }
}

// Vector operations using ARM NEON
void vector_add(vector_reg_t* result, vector_reg_t* a, vector_reg_t* b) {
    result->low = vaddq_s32(a->low, b->low);
    result->high = vaddq_s32(a->high, b->high);
}

void vector_sub(vector_reg_t* result, vector_reg_t* a, vector_reg_t* b) {
    result->low = vsubq_s32(a->low, b->low);
    result->high = vsubq_s32(a->high, b->high);
}

void vector_mul(vector_reg_t* result, vector_reg_t* a, vector_reg_t* b) {
    result->low = vmulq_s32(a->low, b->low);
    result->high = vmulq_s32(a->high, b->high);
}

void vector_div(vector_reg_t* result, vector_reg_t* a, vector_reg_t* b) {
    int32_t a_vals[8], b_vals[8];
    
    // 提取值
    vst1q_s32(a_vals, a->low);
    vst1q_s32(a_vals + 4, a->high);
    vst1q_s32(b_vals, b->low);
    vst1q_s32(b_vals + 4, b->high);
    
    // 执行除法
    for (int i = 0; i < 8; i++) {
        if (b_vals[i] != 0) {
            a_vals[i] /= b_vals[i];
        }
    }
    
    // 加载回NEON寄存器
    result->low = vld1q_s32(a_vals);
    result->high = vld1q_s32(a_vals + 4);
}

// FFT implementation
void vector_fft(vector_reg_t* result, vector_reg_t* input) {
    vector_reg_t temp;
    bit_reverse(&temp, input);
    
    int32_t data[8];
    vst1q_s32(data, temp.low);
    vst1q_s32(data + 4, temp.high);
    
    // 8点FFT的三个阶段
    for (int stage = 0; stage < 3; stage++) {
        int distance = 1 << stage;
        int butterfly = 1 << (stage + 1);
        
        for (int i = 0; i < VECTOR_LENGTH; i += butterfly) {
            for (int j = 0; j < distance; j++) {
                int a_idx = i + j;
                int b_idx = i + j + distance;
                
                // 计算旋转因子
                double angle = -2.0 * M_PI * j / butterfly;
                int32_t twiddle_real = (int32_t)(cos(angle) * 1024);
                int32_t twiddle_imag = (int32_t)(sin(angle) * 1024);
                
                // 蝶形运算
                int32_t temp_real = (data[b_idx] * twiddle_real) >> 10;
                int32_t temp_imag = (data[b_idx] * twiddle_imag) >> 10;
                
                data[b_idx] = data[a_idx] - temp_real;
                data[a_idx] = data[a_idx] + temp_real;
            }
        }
    }
    
    result->low = vld1q_s32(data);
    result->high = vld1q_s32(data + 4);
}

void vector_ifft(vector_reg_t* result, vector_reg_t* input) {
    vector_reg_t temp;
    bit_reverse(&temp, input);
    
    int32_t data[8];
    vst1q_s32(data, temp.low);
    vst1q_s32(data + 4, temp.high);
    
    // 8点IFFT的三个阶段
    for (int stage = 0; stage < 3; stage++) {
        int distance = 1 << stage;
        int butterfly = 1 << (stage + 1);
        
        for (int i = 0; i < VECTOR_LENGTH; i += butterfly) {
            for (int j = 0; j < distance; j++) {
                int a_idx = i + j;
                int b_idx = i + j + distance;
                
                // 计算旋转因子（注意IFFT使用正角度）
                double angle = 2.0 * M_PI * j / butterfly;
                int32_t twiddle_real = (int32_t)(cos(angle) * 1024);
                int32_t twiddle_imag = (int32_t)(sin(angle) * 1024);
                
                // 蝶形运算
                int32_t temp_real = (data[b_idx] * twiddle_real) >> 10;
                int32_t temp_imag = (data[b_idx] * twiddle_imag) >> 10;
                
                // 存储结果并除以8（向量长度）进行归一化
                data[b_idx] = (data[a_idx] - temp_real) >> 3;
                data[a_idx] = (data[a_idx] + temp_real) >> 3;
            }
        }
    }
    
    result->low = vld1q_s32(data);
    result->high = vld1q_s32(data + 4);
}

void vector_sort(vector_reg_t* result, vector_reg_t* input) {
    int32_t data[8];
    vst1q_s32(data, input->low);
    vst1q_s32(data + 4, input->high);
    
    // 8元素双调排序网络
    for (int i = 0; i < 4; i++) {
        if (data[i] > data[i + 4]) {
            int32_t temp = data[i];
            data[i] = data[i + 4];
            data[i + 4] = temp;
        }
    }
    
    // 对每个四元素子序列排序
    for (int i = 0; i < 2; i++) {
        for (int j = 0; j < 2; j++) {
            int idx1 = i * 4 + j * 2;
            int idx2 = idx1 + 1;
            if (data[idx1] > data[idx2]) {
                int32_t temp = data[idx1];
                data[idx1] = data[idx2];
                data[idx2] = temp;
            }
        }
    }
    
    // 最后的比较和交换
    for (int i = 1; i < 7; i += 2) {
        if (data[i] > data[i + 1]) {
            int32_t temp = data[i];
            data[i] = data[i + 1];
            data[i + 1] = temp;
        }
    }
    
    result->low = vld1q_s32(data);
    result->high = vld1q_s32(data + 4);
}

void vector_bitrev(vector_reg_t* dest, const vector_reg_t* src) {
    int32_t data[VECTOR_LENGTH];
    const int32_t* s = (const int32_t*)src;
    
    // Generate bit-reversed indices
    for (int i = 0; i < VECTOR_LENGTH; i++) {
        int j = reverse_bits_helper(i, 3);  // 3 bits for 8 elements
        data[j] = s[i];
    }
    
    // Copy result back
    memcpy(dest, data, sizeof(data));
}

void vector_permute(vector_reg_t* dest, const vector_reg_t* src, const vector_reg_t* perm) {
    int32_t data[VECTOR_LENGTH];
    const int32_t* s = (const int32_t*)src;
    const int32_t* p = (const int32_t*)perm;
    
    // Perform permutation
    for (int i = 0; i < VECTOR_LENGTH; i++) {
        int idx = p[i] & (VECTOR_LENGTH - 1);  // Ensure index is in range
        data[i] = s[idx];
    }
    
    // Copy result back
    memcpy(dest, data, sizeof(data));
}

// 向量规约操作
int32_t vector_reduce(vector_reg_t* input, reduction_op_t op) {
    int32_t result;
    
    int32_t data[8];
    vst1q_s32(data, input->low);
    vst1q_s32(data + 4, input->high);
    
    switch(op) {
        case RED_SUM:
            result = 0;
            for (int i = 0; i < 8; i++) {
                result += data[i];
            }
            break;
            
        case RED_PROD:
            result = 1;
            for (int i = 0; i < 8; i++) {
                result *= data[i];
            }
            break;
            
        case RED_MAX:
            result = data[0];
            for (int i = 1; i < 8; i++) {
                if (data[i] > result) {
                    result = data[i];
                }
            }
            break;
            
        case RED_MIN:
            result = data[0];
            for (int i = 1; i < 8; i++) {
                if (data[i] < result) {
                    result = data[i];
                }
            }
            break;
    }
    
    return result;
}

// 向量扫描操作
void vector_scan(vector_reg_t* result, vector_reg_t* input, reduction_op_t op) {
    int32_t data[8];
    vst1q_s32(data, input->low);
    vst1q_s32(data + 4, input->high);
    
    switch(op) {
        case RED_SUM:
            for (int i = 1; i < 8; i++) {
                data[i] += data[i-1];
            }
            break;
            
        case RED_PROD:
            for (int i = 1; i < 8; i++) {
                data[i] *= data[i-1];
            }
            break;
            
        case RED_MAX:
            for (int i = 1; i < 8; i++) {
                if (data[i-1] > data[i]) {
                    data[i] = data[i-1];
                }
            }
            break;
            
        case RED_MIN:
            for (int i = 1; i < 8; i++) {
                if (data[i-1] < data[i]) {
                    data[i] = data[i-1];
                }
            }
            break;
    }
    
    result->low = vld1q_s32(data);
    result->high = vld1q_s32(data + 4);
}

// 向量比较操作
void vector_compare(vector_reg_t* result, vector_reg_t* a, vector_reg_t* b) {
    result->low = vcgtq_s32(a->low, b->low);
    result->high = vcgtq_s32(a->high, b->high);
}

// 向量条件选择
void vector_select(vector_reg_t* result, vector_reg_t* mask, vector_reg_t* a, vector_reg_t* b) {
    result->low = vbslq_s32(mask->low, a->low, b->low);
    result->high = vbslq_s32(mask->high, a->high, b->high);
}

// 向量位反转置换
static void bit_reverse(vector_reg_t* result, vector_reg_t* input) {
    int32_t data[8];
    vst1q_s32(data, input->low);
    vst1q_s32(data + 4, input->high);
    
    int32_t temp[8];
    for (int i = 0; i < 8; i++) {
        int reversed_idx = reverse_bits_helper(i, 3);  // 3 bits for 8 elements
        temp[reversed_idx] = data[i];
    }
    
    result->low = vld1q_s32(temp);
    result->high = vld1q_s32(temp + 4);
}

#else
// Fallback scalar implementations for non-NEON platforms
void vector_add(vector_reg_t* dest, const vector_reg_t* src1, const vector_reg_t* src2) {
    for (int i = 0; i < VECTOR_LENGTH; i++) {
        (*dest)[i] = (*src1)[i] + (*src2)[i];
    }
}

void vector_sub(vector_reg_t* dest, const vector_reg_t* src1, const vector_reg_t* src2) {
    for (int i = 0; i < VECTOR_LENGTH; i++) {
        (*dest)[i] = (*src1)[i] - (*src2)[i];
    }
}

void vector_mul(vector_reg_t* dest, const vector_reg_t* src1, const vector_reg_t* src2) {
    for (int i = 0; i < VECTOR_LENGTH; i++) {
        (*dest)[i] = (*src1)[i] * (*src2)[i];
    }
}

void vector_div(vector_reg_t* dest, const vector_reg_t* src1, const vector_reg_t* src2) {
    for (int i = 0; i < VECTOR_LENGTH; i++) {
        if ((*src2)[i] != 0) {
            (*dest)[i] = (*src1)[i] / (*src2)[i];
        }
    }
}

// ... (other fallback implementations remain the same)
#endif 